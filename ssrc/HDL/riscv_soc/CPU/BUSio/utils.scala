package riscv_soc.bus

import chisel3._
import chisel3.util._

import chisel3.util.BitPat

import freechips.rocketchip.subsystem._
import org.chipsalliance.cde.config.{Field, Parameters}
import freechips.rocketchip.diplomacy._
import freechips.rocketchip.tilelink._
import freechips.rocketchip.util._
import freechips.rocketchip.devices.tilelink._
import freechips.rocketchip.amba.axi4._
import freechips.rocketchip.system._

// total instruction num: 35

object ChipLinkParam {
  // Must have a cacheable address sapce.
  val mem  = AddressSet(0xc0000000L, 0x40000000L - 1)
  val mmio = AddressSet(0x40000000L, 0x40000000L - 1)
  val allSpace = Seq(mem, mmio)
  val idBits = 4
}

object Instructions {
  // Loads
  def LB     = "b?????????????????000?????0000011"
  def LH     = "b?????????????????001?????0000011"
  def LW     = "b?????????????????010?????0000011"
  def LBU    = "b?????????????????100?????0000011"
  def LHU    = "b?????????????????101?????0000011"
  // Stores
  def SB     = "b?????????????????000?????0100011"
  def SH     = "b?????????????????001?????0100011"
  def SW     = "b?????????????????010?????0100011"
  // Shifts
  def SLL    = "b0000000??????????001?????0110011"
  def SLLI   = "b0000000??????????001?????0010011"
  def SRL    = "b0000000??????????101?????0110011"
  def SRLI   = "b0000000??????????101?????0010011"
  def SRA    = "b0100000??????????101?????0110011"
  def SRAI   = "b0100000??????????101?????0010011"
  // Arithmetic
  def ADD    = "b0000000??????????000?????0110011"
  def ADDI   = "b?????????????????000?????0010011"
  def SUB    = "b0100000??????????000?????0110011"
  def LUI    = "b?????????????????????????0110111"
  def AUIPC  = "b?????????????????????????0010111"
  // Logical
  def XOR    = "b0000000??????????100?????0110011"
  def XORI   = "b?????????????????100?????0010011"
  def OR     = "b0000000??????????110?????0110011"
  def ORI    = "b?????????????????110?????0010011"
  def AND    = "b0000000??????????111?????0110011"
  def ANDI   = "b?????????????????111?????0010011"
  // Compare
  def SLT    = "b0000000??????????010?????0110011"
  def SLTI   = "b?????????????????010?????0010011"
  def SLTU   = "b0000000??????????011?????0110011"
  def SLTIU  = "b?????????????????011?????0010011"
  // Branches
  def BEQ    = "b?????????????????000?????1100011"
  def BNE    = "b?????????????????001?????1100011"
  def BLT    = "b?????????????????100?????1100011"
  def BGE    = "b?????????????????101?????1100011"
  def BLTU   = "b?????????????????110?????1100011"
  def BGEU   = "b?????????????????111?????1100011"
  // Jump & Link
  def JAL    = "b?????????????????????????1101111"
  def JALR   = "b?????????????????000?????1100111"
  // Synch
  def FENCE  = "b0000????????00000000000000001111"
  def FENCEI = "b00000000000000000001000000001111"
  // CSR Access
  def CSRRW  = "b?????????????????001?????1110011"
  def CSRRS  = "b?????????????????010?????1110011"
  def CSRRC  = "b?????????????????011?????1110011"
  def CSRRWI = "b?????????????????101?????1110011"
  def CSRRSI = "b?????????????????110?????1110011"
  def CSRRCI = "b?????????????????111?????1110011"
  // Change Level
  def ECALL  = "b00000000000000000000000001110011"
  def EBREAK = "b00000000000100000000000001110011"
  def ERET   = "b00010000000000000000000001110011"
  def WFI    = "b00010000001000000000000001110011"

  def MRET   = "b00110000001000000000000001110011"
  def NOP    = "b00000000000000000000000000010011"
}

object Special_instTypeEnum extends ChiselEnum {
  val None,
      fence_I
      = Value
}

object Imm_TypeEnum extends ChiselEnum{
  val Imm_I = Value((1 << 0).U)
  val Imm_U = Value((1 << 1).U)
  val Imm_S = Value((1 << 2).U)
  val Imm_B = Value((1 << 3).U)
  val Imm_J = Value((1 << 4).U)
}

object IsLogic extends ChiselEnum {
  val EQ = Value((1 << 0).U)
  val NE = Value((1 << 1).U)

  val LT = Value((1 << 2).U)
  val GE = Value((1 << 3).U)

  val LTU = Value((1 << 4).U)
  val GEU = Value((1 << 5).U)

  val SLTI = Value((1 << 6).U)
  val SLTIU = Value((1 << 7).U)
}

object Inst_Type extends ChiselEnum {
  val 
      AL,
      LS

      = Value
}

object SRCA extends ChiselEnum {
  val 
      RS1,
      PC,
      ZERO,
      CSR

      = Value
}

object SRCB extends ChiselEnum {
  val 
      RS1,
      RS2,
      IMM,
      LogicBranch,
      LogicSet

      = Value
}

class IsCtrl extends Bundle {
  val inst_Type = Inst_Type()
  val isLogic = IsLogic()
  val srca = SRCA()
  val srcb = SRCB()
}

object AlCtrl extends ChiselEnum {
  val ADD = Value((1 << 0).U)
  val SUB = Value((1 << 1).U)

  val AND = Value((1 << 2).U)
  val OR  = Value((1 << 3).U)
  val XOR = Value((1 << 4).U)
  
  val SLL = Value((1 << 5).U)
  val SRL = Value((1 << 6).U)
  val SRA = Value((1 << 7).U)
}

object LsCtrl extends ChiselEnum {
  val LB,
      LH,
      LW,
      LBU,
      LHU,

      SB,
      SH,
      SW
      = Value
}

object CSR_TypeEnum extends ChiselEnum{
  val CSR_N   ,    // 非csr读写指令
      CSR_R1W0,    // 不读写一， 目前只有 mret 符合
      CSR_R1W1,    // 读写一
      CSR_R1W2     // 读一写二， 目前只有 ecall 符合
      = Value
}

object signal_value {
  def Y = true.B
  def N = false.B
}

object bus_state extends ChiselEnum{
  val s_wait_valid,
      s_wait_ready,
      s_busy,
      s_pipeline
      = Value
}

// new enums
object WbCtrl extends ChiselEnum {
  val Write_GPR,
      Jump,
      Csr
      = Value
}

object Trap_type extends ChiselEnum {
  val Instruction_address_misaligned = Value(0.U)
  val Ebreak = Value(3.U)
  val EcallM = Value(11.U)
}

class trap extends Bundle {
  val traped = Bool()
  val trap_type = Trap_type()
}
