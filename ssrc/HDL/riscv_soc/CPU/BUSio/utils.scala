package riscv_soc.bus

import chisel3._
import chisel3.util._

import chisel3.util.BitPat

import freechips.rocketchip.subsystem._
import org.chipsalliance.cde.config.{Field, Parameters}
import freechips.rocketchip.diplomacy._
import freechips.rocketchip.tilelink._
import freechips.rocketchip.util._
import freechips.rocketchip.devices.tilelink._
import freechips.rocketchip.amba.axi4._
import freechips.rocketchip.system._

// total instruction num: 35

object ChipLinkParam {
  // Must have a cacheable address sapce.
  val mem  = AddressSet(0xc0000000L, 0x40000000L - 1)
  val mmio = AddressSet(0x40000000L, 0x40000000L - 1)
  val allSpace = Seq(mem, mmio)
  val idBits = 4
}

object Instructions {
  // Loads
  def LB     = "b?????????????????000?????0000011"
  def LH     = "b?????????????????001?????0000011"
  def LW     = "b?????????????????010?????0000011"
  def LBU    = "b?????????????????100?????0000011"
  def LHU    = "b?????????????????101?????0000011"
  // Stores
  def SB     = "b?????????????????000?????0100011"
  def SH     = "b?????????????????001?????0100011"
  def SW     = "b?????????????????010?????0100011"
  // Shifts
  def SLL    = "b0000000??????????001?????0110011"
  def SLLI   = "b0000000??????????001?????0010011"
  def SRL    = "b0000000??????????101?????0110011"
  def SRLI   = "b0000000??????????101?????0010011"
  def SRA    = "b0100000??????????101?????0110011"
  def SRAI   = "b0100000??????????101?????0010011"
  // Arithmetic
  def ADD    = "b0000000??????????000?????0110011"
  def ADDI   = "b?????????????????000?????0010011"
  def SUB    = "b0100000??????????000?????0110011"
  def LUI    = "b?????????????????????????0110111"
  def AUIPC  = "b?????????????????????????0010111"
  // Logical
  def XOR    = "b0000000??????????100?????0110011"
  def XORI   = "b?????????????????100?????0010011"
  def OR     = "b0000000??????????110?????0110011"
  def ORI    = "b?????????????????110?????0010011"
  def AND    = "b0000000??????????111?????0110011"
  def ANDI   = "b?????????????????111?????0010011"
  // Compare
  def SLT    = "b0000000??????????010?????0110011"
  def SLTI   = "b?????????????????010?????0010011"
  def SLTU   = "b0000000??????????011?????0110011"
  def SLTIU  = "b?????????????????011?????0010011"
  // Branches
  def BEQ    = "b?????????????????000?????1100011"
  def BNE    = "b?????????????????001?????1100011"
  def BLT    = "b?????????????????100?????1100011"
  def BGE    = "b?????????????????101?????1100011"
  def BLTU   = "b?????????????????110?????1100011"
  def BGEU   = "b?????????????????111?????1100011"
  // Jump & Link
  def JAL    = "b?????????????????????????1101111"
  def JALR   = "b?????????????????000?????1100111"
  // Synch
  def FENCE  = "b0000????????00000000000000001111"
  def FENCEI = "b00000000000000000001000000001111"
  // CSR Access
  def CSRRW  = "b?????????????????001?????1110011"
  def CSRRS  = "b?????????????????010?????1110011"
  def CSRRC  = "b?????????????????011?????1110011"
  def CSRRWI = "b?????????????????101?????1110011"
  def CSRRSI = "b?????????????????110?????1110011"
  def CSRRCI = "b?????????????????111?????1110011"
  // Change Level
  def ECALL  = "b00000000000000000000000001110011"
  def EBREAK = "b00000000000100000000000001110011"
  def ERET   = "b00010000000000000000000001110011"
  def WFI    = "b00010000001000000000000001110011"

  def MRET   = "b00110000001000000000000001110011"
  def NOP    = "b00000000000000000000000000010011"
}

object Special_instTypeEnum extends ChiselEnum {
  val None,
      fence_I
      = Value
}

object Imm_TypeEnum extends ChiselEnum{
  val Imm_I,    //I型指令
      Imm_U,    //U型指令
      Imm_S,    //S型指令
      Imm_B,    //B型指令
      Imm_J     //J型指令
      = Value
}

object Bran_TypeEnum extends ChiselEnum{
  val Bran_NJmp,   //非跳转
      Bran_Jmp,    //无条件跳转
      Bran_Jmpr,   //寄存器基址跳转
      Bran_Jeq,    //相等跳转
      Bran_Jne,    //不相等跳转
      Bran_Jlt,    //小于跳转
      Bran_Jge,    //大于等于跳转
      Bran_Jcsr    //CSR跳转
      = Value
}

object MemOp_TypeEnum extends ChiselEnum{
  val MemOp_1BU,
      MemOp_1BS,
      MemOp_2BU,
      MemOp_2BS,
      MemOp_4BU
      = Value
}

object RegWr_TypeEnum extends ChiselEnum{
  val RegWr_No,
      RegWr_Yes
      = Value
}

object EXUAsrc_TypeEnum extends ChiselEnum{
  val EXUAsrc_RS1, //寄存器资源1
      EXUAsrc_PC   //PC寄存器
      = Value
}

object EXUBsrc_TypeEnum extends ChiselEnum{
  val EXUBsrc_RS2,  //寄存器资源2
      EXUBsrc_IMM,  //立即数
      EXUBsrc_CSR  //CSR寄存器
      = Value
}

object EXUctr_TypeEnum extends ChiselEnum{
  val EXUctr_ADD     ,    //加法
      EXUctr_SUB     ,    //减法
      EXUctr_Less_U  ,    //小于无符号
      EXUctr_Less_S  ,    //小于
      EXUctr_A       ,    //输出A
      EXUctr_B       ,    //输出B
      EXUctr_SLL     ,    //逻辑左移
      EXUctr_SRL     ,    //逻辑右移
      EXUctr_SRA     ,    //算术右移
      EXUctr_XOR     ,    //异或
      EXUctr_OR      ,    //或
      EXUctr_AND     ,    //与
      EXUctr_LD      ,    
      EXUctr_ST
      = Value
}

object IsLogic extends ChiselEnum {
  val 
      EQ,
      NE,

      LT,
      GE,

      LTU,
      GEU,

      SLTI,
      SLTIU

      = Value
}

object Inst_Type extends ChiselEnum {
  val 
      AL,
      LS

      = Value
}

object SRCA extends ChiselEnum {
  val 
      RS1,
      ZERO,
      PC

      = Value
}

object SRCB extends ChiselEnum {
  val 
      RS2,
      IMM,
      LogicBranch,
      LogicSet

      = Value
}

class IsCtrl extends Bundle {
  val inst_Type = Inst_Type()
  val isLogic = IsLogic()
  val srca = SRCA()
  val srcb = SRCB()
}

object AlCtrl extends ChiselEnum {
  val 
      ADD,
      SUB,

      AND,
      OR,
      XOR,

      SLL,
      SRL,
      SRA

      = Value
}

object LsCtrl extends ChiselEnum {
  val LB,
      LH,
      LW,
      LBU,
      LHU,

      SB,
      SH,
      SW
      = Value
}

object CSR_TypeEnum extends ChiselEnum{
  val CSR_N   ,    // 非csr读写指令
      CSR_R1W0,    // 不读写一， 目前只有 mret 符合
      CSR_R1W1,    // 读写一
      CSR_R1W2     // 读一写二， 目前只有 ecall 符合
      = Value
}

object signal_value {
  def Y = true.B
  def N = false.B
}

object bus_state extends ChiselEnum{
  val s_wait_valid,
      s_wait_ready,
      s_busy,
      s_pipeline
      = Value
}

// new enums
object WbCtrl extends ChiselEnum {
  val Write_GPR,
      Jump,
      Csr
      = Value
}

object Trap_type extends ChiselEnum {
  val Instruction_address_misaligned = Value(0.U)
  val Ebreak = Value(3.U)
  val EcallM = Value(11.U)
}

class trap extends Bundle {
  val traped = Bool()
  val trap_type = Trap_type()
}
